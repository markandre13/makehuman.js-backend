// This file is generated by the corba.js IDL compiler from 'makehuman.idl'.

#include <corba/corba.hh>
#include <corba/orb.hh>
#include <corba/giop.hh>
#include <corba/coroutine.hh>
#include <cstring>
#include <vector>
#include <map>
#include <functional>
#include "makehuman.hh"
#include "makehuman_skel.hh"
#include "makehuman_stub.hh"

static CORBA::async<> _Backend_hello(Backend *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->hello(decoder.readStringView());
    encoder.writeString(result);
}
CORBA::async<std::string> Backend_stub::hello(const std::string_view & hello) {
    return get_ORB()->twowayCall<std::string>(this, "hello", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeString(hello);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.readString(); });
}
static CORBA::async<> _Backend_fail(Backend *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    co_await obj->fail();
}
CORBA::async<void> Backend_stub::fail() {
    return get_ORB()->twowayCall(this, "fail", [&](CORBA::GIOPEncoder &encoder) {
    });
}
std::map<std::string_view, std::function<CORBA::async<>(Backend *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder)>> _op_Backend = {
    {"hello", _Backend_hello},
    {"fail", _Backend_fail},
};
CORBA::async<> Backend_skel::_call(const std::string_view &operation, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto it = _op_Backend.find(operation);
    if (it == _op_Backend.end()) {
        throw CORBA::BAD_OPERATION(0, CORBA::YES);
    }
    co_await it->second(this, decoder, encoder);
};

std::string_view Backend::_rid("IDL:Backend:1.0");
std::string_view Backend::repository_id() const { return _rid;}

CORBA::async<std::shared_ptr<Backend>> Backend::_narrow(std::shared_ptr<CORBA::Object> pointer) {
    auto ptr = pointer.get();
    auto ref = dynamic_cast<CORBA::IOR *>(ptr);
    if (ref) {
        if (ref->repository_id() != "IDL:Backend:1.0") {
            co_return std::shared_ptr<Backend>();
        }
        std::shared_ptr<CORBA::ORB> orb = ref->get_ORB();
        CORBA::detail::Connection *conn = co_await orb->getConnection(ref->host, ref->port);
        auto stub = std::make_shared<Backend_stub>(orb, CORBA::blob_view(ref->objectKey), conn);
        co_return std::dynamic_pointer_cast<Backend>(stub);
    }
    auto obj = dynamic_cast<Backend*>(ptr);
    if (obj) {
        co_return std::dynamic_pointer_cast<Backend>(pointer);
    }
    co_return std::shared_ptr<Backend>();
}

static CORBA::async<> _Backend2_chordata(Backend2 *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    obj->chordata(decoder.readBoolean());
    co_return;
}
void Backend2_stub::chordata(bool on) {
    get_ORB()->onewayCall(this, "chordata", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeBoolean(on);
    });
}
static CORBA::async<> _Backend2_mediapipe(Backend2 *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    obj->mediapipe(decoder.readBoolean());
    co_return;
}
void Backend2_stub::mediapipe(bool on) {
    get_ORB()->onewayCall(this, "mediapipe", [&](CORBA::GIOPEncoder &encoder) {
        encoder.writeBoolean(on);
    });
}
std::map<std::string_view, std::function<CORBA::async<>(Backend2 *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder)>> _op_Backend2 = {
    {"chordata", _Backend2_chordata},
    {"mediapipe", _Backend2_mediapipe},
};
CORBA::async<> Backend2_skel::_call(const std::string_view &operation, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto it = _op_Backend2.find(operation);
    if (it == _op_Backend2.end()) {
        throw CORBA::BAD_OPERATION(0, CORBA::YES);
    }
    co_await it->second(this, decoder, encoder);
};

std::string_view Backend2::_rid("IDL:Backend2:1.0");
std::string_view Backend2::repository_id() const { return _rid;}

CORBA::async<std::shared_ptr<Backend2>> Backend2::_narrow(std::shared_ptr<CORBA::Object> pointer) {
    auto ptr = pointer.get();
    auto ref = dynamic_cast<CORBA::IOR *>(ptr);
    if (ref) {
        if (ref->repository_id() != "IDL:Backend2:1.0") {
            co_return std::shared_ptr<Backend2>();
        }
        std::shared_ptr<CORBA::ORB> orb = ref->get_ORB();
        CORBA::detail::Connection *conn = co_await orb->getConnection(ref->host, ref->port);
        auto stub = std::make_shared<Backend2_stub>(orb, CORBA::blob_view(ref->objectKey), conn);
        co_return std::dynamic_pointer_cast<Backend2>(stub);
    }
    auto obj = dynamic_cast<Backend2*>(ptr);
    if (obj) {
        co_return std::dynamic_pointer_cast<Backend2>(pointer);
    }
    co_return std::shared_ptr<Backend2>();
}

