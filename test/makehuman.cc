// This file is generated by the corba.js IDL compiler from 'makehuman.idl'.

#include <corba/corba.hh>
#include <corba/orb.hh>
#include <corba/giop.hh>
#include <corba/coroutine.hh>
#include <cstring>
#include <vector>
#include <map>
#include <functional>
#include "makehuman.hh"
#include "makehuman_skel.hh"
#include "makehuman_stub.hh"

static CORBA::async<> _hello(Backend *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto result = co_await obj->hello(decoder.string());
    encoder.string(result);
}
CORBA::async<std::string> Backend_stub::hello(std::string_view hello) {
    return get_ORB()->twowayCall<std::string>(this, "hello", [&](CORBA::GIOPEncoder &encoder) {
        encoder.string(hello);
    },
    [&](CORBA::GIOPDecoder &decoder) { return decoder.string(); });
}
static CORBA::async<> _fail(Backend *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    co_await obj->fail();
}
CORBA::async<void> Backend_stub::fail() {
    return get_ORB()->twowayCall(this, "fail", [&](CORBA::GIOPEncoder &encoder) {
    });
}
std::map<std::string_view, std::function<CORBA::async<>(Backend *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder)>> _op_Backend = {
    {"hello", _hello},
    {"fail", _fail},
};
CORBA::async<> Backend_skel::_call(const std::string_view &operation, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto it = _op_Backend.find(operation);
    if (it == _op_Backend.end()) {
        throw CORBA::BAD_OPERATION(0, CORBA::YES);
    }
    co_await it->second(this, decoder, encoder);
};

std::shared_ptr<Backend> Backend::_narrow(std::shared_ptr<CORBA::Object> pointer) {
    auto ptr = pointer.get();
    auto ref = dynamic_cast<CORBA::ObjectReference *>(ptr);
    if (ref) {
        if (std::strcmp(ref->repository_id(), "IDL:Backend:1.0") != 0) {
            return std::shared_ptr<Backend>();
        }
        CORBA::ORB *orb = ref->get_ORB();
        CORBA::detail::Connection *conn = orb->getConnection(ref->host, ref->port);
        auto stub = std::make_shared<Backend_stub>(orb, CORBA::blob_view(ref->objectKey), conn);
        return std::dynamic_pointer_cast<Backend>(stub);
    }
    auto obj = dynamic_cast<Backend*>(ptr);
    if (obj) {
        return std::dynamic_pointer_cast<Backend>(pointer);
    }
    return std::shared_ptr<Backend>();
}

static CORBA::async<> _chordata(Backend2 *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    obj->chordata(decoder.boolean());
    co_return;
}
void Backend2_stub::chordata(bool on) {
    get_ORB()->onewayCall(this, "chordata", [&](CORBA::GIOPEncoder &encoder) {
        encoder.boolean(on);
    });
}
static CORBA::async<> _mediapipe(Backend2 *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    obj->mediapipe(decoder.boolean());
    co_return;
}
void Backend2_stub::mediapipe(bool on) {
    get_ORB()->onewayCall(this, "mediapipe", [&](CORBA::GIOPEncoder &encoder) {
        encoder.boolean(on);
    });
}
std::map<std::string_view, std::function<CORBA::async<>(Backend2 *obj, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder)>> _op_Backend2 = {
    {"chordata", _chordata},
    {"mediapipe", _mediapipe},
};
CORBA::async<> Backend2_skel::_call(const std::string_view &operation, CORBA::GIOPDecoder &decoder, CORBA::GIOPEncoder &encoder) {
    auto it = _op_Backend2.find(operation);
    if (it == _op_Backend2.end()) {
        throw CORBA::BAD_OPERATION(0, CORBA::YES);
    }
    co_await it->second(this, decoder, encoder);
};

std::shared_ptr<Backend2> Backend2::_narrow(std::shared_ptr<CORBA::Object> pointer) {
    auto ptr = pointer.get();
    auto ref = dynamic_cast<CORBA::ObjectReference *>(ptr);
    if (ref) {
        if (std::strcmp(ref->repository_id(), "IDL:Backend2:1.0") != 0) {
            return std::shared_ptr<Backend2>();
        }
        CORBA::ORB *orb = ref->get_ORB();
        CORBA::detail::Connection *conn = orb->getConnection(ref->host, ref->port);
        auto stub = std::make_shared<Backend2_stub>(orb, CORBA::blob_view(ref->objectKey), conn);
        return std::dynamic_pointer_cast<Backend2>(stub);
    }
    auto obj = dynamic_cast<Backend2*>(ptr);
    if (obj) {
        return std::dynamic_pointer_cast<Backend2>(pointer);
    }
    return std::shared_ptr<Backend2>();
}

